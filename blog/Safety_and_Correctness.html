<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Safety and Correctness</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  /* https://github.com/markdowncss/retro/blob/master/css/retro.css */

  @font-face {
      font-family: "lemon";
      src: url('lemon.woff');
  }

  /*
  @media print {
      *, *:before, *:after {
          background: transparent !important;
          color: #000 !important;
          box-shadow: none !important;
          text-shadow: none !important;
      }
      a, a:visited { text-decoration: underline; }
      a[href]:after { content: " (" attr(href) ")"; }
      abbr[title]:after { content: " (" attr(title) ")"; }
      a[href^="#"]:after, a[href^="javascript:"]:after { content: ""; }
      pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
      thead { display: table-header-group; }
      tr, img { page-break-inside: avoid; }
      img { max-width: 100% !important; }
      p, h2, h3 { orphans: 3; widows: 3; }
      h2, h3 { page-break-after: avoid; }
  }
  */
  a, a:visited { color: #01ff70; }
  a:hover, a:focus, a:active { color: #2ecc40; }
  .retro-no-decoration { text-decoration: none; }
  p, .retro-p {
      font-size: 1rem;
      margin-bottom: 1.3rem;
      /*text-indent: 50px*/
  }
  h1, .retro-h1, h2, .retro-h2, h3, .retro-h3, h4, .retro-h4 {
      font-family: "lemon";
      margin: 1.414rem 0 .5rem;
      font-weight: inherit;
      line-height: 1.42;
  }
  h1, .retro-h1 {
      color: rgb(112, 221, 0);
      margin-top: 0;
      font-size: 3.998rem;
  }
  h2, .retro-h2 {
      color: rgb(112, 221, 0);
      margin-top: 0;
      font-size: 2.827rem;
  }
  h3, .retro-h3 {
      font-size: 1.999rem;
  }
  h4, .retro-h4 {
      font-size: 1.414rem;
  }
  h5, .retro-h5 {
      font-size: 1.121rem;
  }
  h6, .retro-h6 {
      font-size: .88rem;
  }
  small, .retro-small {
      font-size: .707em;
  }

  img, canvas, iframe, video, svg, select, textarea { max-width: 100%; }

  html, body {
      /* background-image: url(https://raw.githubusercontent.com/apaz-cli/apaz-cli.github.io/master/pattern.png); */
      background-color: #222;
      min-height: 100%;
      font-size: 20px;
  }
  body {
      color: #fafafa;
      /* font-family:  "lemon", "Courier New"; */
      line-height: 1.65;
      margin: 6rem auto 1rem;
      max-width: 48rem;
      /* padding: .25rem; */
  }
  pre, code {
      background-color: #333;
      font-family: "lemon", "Menlo", "Monaco", "Courier New";
      font-size: 12;
  }

  code span.dt { color: #e4a51e; } /* DataType */

  pre {
      padding: .5rem;
      line-height: 1.25;
      overflow-x: scroll;
  }
  blockquote {
      border-left: 3px solid #01ff70;
      padding-left: 1rem;
  }
  </style>
</head>
<body>
<h1 id="safety-and-correctness">Safety and Correctness</h1>
<p>Software safety is a lofty, but poorly defined goal.</p>
<p>Everybody has their own opinion about how to achieve "safety" in software. Especially in the world of airplane firmware. However, nobody really seems to know what that means. One engineer's definition of what safe software looks like will be drastically different from the one sitting next to them. This won't resolve the debate in any meaningful capacity, but here's my own interpretation.</p>
<p><img src="images/PlaneClouds_skyrick9413.jpg" /></p>
<p>Luckily, the vast majority of airplane firmware hasn't killed people. Not killing anybody is admirable, but still not actionable enough to be useful. The <a href="https://en.wikipedia.org/wiki/MISRA_C">MISRA C</a> standards are good, and <a href="https://en.wikipedia.org/wiki/DO-178C">DO-178C</a> does guarantee a minimum level of safety through sheer amount of expensive documentation and testing effort, but both standards leave much to be desired. I'm left wondering what it is we're all chasing.</p>
<p>Today, I watched a CPPCon talk that unified everything I know on the topic. The talk is about <code>std::find()</code> and <code>std::find_if()</code> from C++, but the points that it made along the way are what resonated with me. It brought together my experiences designing a Java perceptual image processing research library, and my time spent designing, writing, debugging, and verifying engine controller and weapons systems firmware in C. Honestly, I wish it all clicked sooner.</p>
<p>This post is written about C and C++, but using other languages does not excuse you from having to think about these things. The common phrase that people use is "just because the language is safe, that doesn't mean the code you wrote is correct." Now I have a way to express what that means.</p>
<p>This new perspective presents an interesting and actionable path forward for the tooling surrounding Daisho and other programming languages. It may also solve some unique challenges inside the C portion of the Daisho standard library, as well as the age-old problem of what to do about a specific class of dangerous and difficult to track down UB bugs coming from problems like signed integer overflow, oversize shifts, and division by zero.</p>
<p><br></p>
<h2 id="the-video">The Video:</h2>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/2FAi2mNYjFA?start=1430" title="YouTube video player" frameborder="0" allow="encrypted-media; picture-in-picture" align="center " allowfullscreen>
</iframe>
</center>
<p><br></p>
<h2 id="definitions">Definitions</h2>
<h3 id="preconditions-and-postconditions">Preconditions and Postconditions</h3>
<p><a href="https://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a> describes computations as a Hoare triple <code>{P}C{Q}</code> where <code>P</code> is assertions about preconditions, <code>Q</code> is assertions about postconditions, and <code>C</code> is the code being described. What I'm about to describe is not Hoare logic. But the ideas of Hoare logic (computations having well defined preconditions and postconditions) are what prop up the upcoming definitions of safety and correctness.</p>
<p>Instead of using the definition provided by Hoare Logic, let's define the preconditions of a computation (or function or snippet) as the expected set of possible states that the program can be in before the computation takes place, relevant to the computation.</p>
<p>Likewise, postconditions are the expected set of possible states the program can be in after the computation, also relevant to the computation.</p>
<p>Even when we don't constantly try, odds are that we already think about functions as having preconditions and postconditions. If your code is well written, composed primarily of functions, and those functions are well named, then odds are that you have a good idea what your preconditions and postconditions are. But, you probably don't know exactly what they are. In fact, you almost definitely don't. Specifying the preconditions and postconditions of parts of your program can be an iterative process. You can design them up front, but the implementation of your program will almost certainly introduce new ones.</p>
<p>In the aerospace industry, we are forced to think in terms of preconditions and postconditions. It's the nature of requirements based development, which is mandated by the FAA. However, we are forced to think about them from a requirements level, rather than an implementation level. The expectation is that the implementation is left up to the software engineer, and its correctness will come out in code review. The remainder of this post deals with the implementation level, not the requirements level.</p>
<h3 id="safety">Safety:</h3>
<p>An operation is safe if it cannot lead to undefined behavior, either directly or indirectly, even if the operation's preconditions are violated. Otherwise, it is unsafe.</p>
<p>Safety only specifies whether every possible set of preconditions maps to a postcondition. It has nothing to do with whether those postconditions are intended, only what happens when unexpected conditions occur.</p>
<h3 id="correctness">Correctness:</h3>
<p>An operation that is correct satisfies the intended postconditions if its preconditions are satisfied.</p>
<p>Correctness implies that you've thought about every possible precondition, and can justify that it maps to the intended postcondition.</p>
<p>Correctness is incredibly difficult to obtain or be confident about. Hopefully the next section will convince you of that.</p>
<h3 id="bug">Bug:</h3>
<p>A bug is a violation of correctness. Not all bugs become observable unintended behavior.</p>
<p><br></p>
<h2 id="why-do-we-write-unsafe-programs">Why do we write unsafe programs?</h2>
<p>Undefined Behavior introduces silent preconditions that are difficult to detect and reason about. Is the following code safe? Stare at it for a while.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">char</span> strDeref(<span class="dt">const</span> <span class="dt">char</span> *str, <span class="dt">int</span> idx1, <span class="dt">int</span> idx2) {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="cf">if</span> (str == NULL)</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="cf">if</span> ((idx1 + idx2) &lt; <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="cf">if</span> (strnlen(str, <span class="dv">1000</span>) &lt;= (idx1 + idx2))</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a>  <span class="cf">return</span> str[idx1 + idx2];</span>
<span id="cb1-12"><a href="#cb1-12"></a>}</span></code></pre></div>
<p>I would say that it sure looks right. But that's not what safe means.</p>
<p>Even if you think you're covering all of your bases by checking the length of the string, and even using <code>strnlen()</code> over <code>strlen()</code> to do so because it's "safer" (that doesn't make it less dangerous), it's very hard to make sure your API is safe. The problem is <code>idx1 + idx2</code>. Signed integer overflow is undefined. So are a lot of other things. Truly safe code is difficult to achieve. Or it's literally impossible in some cases (in C, almost all cases). There are some other UB problems that can be fixed this way as well, just by checking before the operation that would trigger them. Oversize shift amounts and pointer alignment fall into this category.</p>
<p>Let's fix the above example.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">char</span> strDeref(<span class="dt">const</span> <span class="dt">char</span> *str, <span class="dt">int</span> idx1, <span class="dt">int</span> idx2) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="cf">if</span> ((idx1 &gt; <span class="dv">0</span> &amp;&amp; idx2 &gt; INT_MAX - idx1)</span>
<span id="cb2-3"><a href="#cb2-3"></a>   || (idx1 &lt; <span class="dv">0</span> &amp;&amp; idx2 &lt; INT_MIN - idx1))</span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="co">/* str is aligned, since char* has no alignment requirements. */</span></span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="cf">if</span> (str == NULL)</span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="cf">if</span> ((idx1 + idx2) &lt; <span class="dv">0</span>)</span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="cf">if</span> (strnlen(str, <span class="dv">1000</span>) &lt;= (idx1 + idx2))</span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a>  <span class="cf">return</span> str[idx1 + idx2];</span>
<span id="cb2-18"><a href="#cb2-18"></a>}</span></code></pre></div>
<p>Surely now it's safe for any possible preconditions, right? I raise you the following.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a>strDeref((<span class="dt">char</span> *)(<span class="dt">void</span> *)(<span class="dt">intptr_t</span>)<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>);</span></code></pre></div>
<p>Checking whether a memory region is valid is very difficult. It seems at this point that we're out of luck. We can't (reasonably) fix this. It's doable theoretically, but would require so much instrumentation that it would be easier just to buy the whole orchestra.</p>
<p>Luckily, people don't often write code like this that's so obviously wrong. We know that dereferencing a wild pointer (one that isn't aligned inside of a valid memory region) is bad. But there are less obvious ways to obtain a pointer to an invalid memory region. We've covered the null pointer case, but there's also use after free. Unless we can guarantee that <code>str</code> is valid and aligned, we cannot call this function safely. It could cause undefined behavior by dereferencing that pointer, which is unfortunately the entire point of the function.</p>
<p>From a language design perspective, it doesn't have to be this way. What if the creation of that pointer was the undefined behavior? What if obtaining such a pointer were impossible? What should the programming language's role in this be? We'll get to my opinions on that later.</p>
<p>The code above is unsafe. But notably, it is not incorrect. I think we can agree that, even without all the checks, it does what you want it to for all sensible inputs. What exactly constitutes a "sensible input" is what we have to define here. Most programmers do not define their preconditions, and instead rely on tacit knowledge. We know that passing an invalid pointer probably violates some preconditions, so we don't. When we want to add two numbers, we don't think about the domain of the inputs. We also don't think to document that the behavior of our function is undefined if <code>((a &gt; 0 &amp;&amp; b &gt; INT_MAX - a) || (a &lt; 0 &amp;&amp; b &lt; INT_MIN - a))</code>. Instead, we just document what our code is supposed to do and go by feel. This is true even in the airplane firmware world.</p>
<p>What's above is just a simple example. We have our definition, but with respect to our current practice of fuzzy preconditions, what does "correct" mean? Our definition assumes preconditions and postconditions are well defined. How APIs compose with respect to preconditions and postconditions gets progressively more difficult to reason about. Once your codebase approaches a certain size, it's anyone's guess.</p>
<p><br></p>
<h2 id="what-should-we-do-about-software-safety">What should we do about software safety?</h2>
<p>There's been decades of argument over whether or not the compiler should try to stop you from writing bugs. That argument is still ongoing in the programming languages world. Rust says yes. C and C++ have been saying no for decades.</p>
<p>Regardless of your opinion on this, perhaps you would agree that it would be cool if our compiler could help us keep bugs out of code that we release out into the world. Making them impossible to write by adding rules to the syntax and type system is not the only way to accomplish this. We can also accomplish it through tooling.</p>
<p>It should also be noted that writing your code is the easy, non-time consuming part. Debugging your code is going to take longer. Undefined behavior is difficult to debug, so it's going to have to go, at least for debug builds.</p>
<p><br></p>
<h2 id="background-the-halting-problem">Background: The Halting Problem</h2>
<p>In the general case, detecting runtime conditions like those that would trigger undefined behavior is provably impossible by reduction to the <a href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a>, first proven by <a href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a> in 1936. The proof is really fun, I suggest looking into it.</p>
<p>There are some programs that do obviously halt for all inputs, like <code>print("Hello World!");</code>. There are also some that obviously never halt like <code>while (true)</code>. But, there's a lot of them for which termination analysis is much more difficult. You could of course write programs to partially answer the halting problem, most optimizing compilers contain one or more mechanisms to attempt to make that determination, but the problem is still unsolvable in the general case.</p>
<p><br></p>
<h2 id="what-is-the-bare-minimum-that-our-tooling-can-do">What is the bare minimum that our tooling can do?</h2>
<p>Since a compiler cannot solve the halting problem, it cannot detect undefined behavior at compile time. However, it can be detected at runtime. That's obviously no problem. It's easy, in fact. Just wrap every condition that could cause it.</p>
<p>Obviously, this is not a complete solution. There are a lot of kinds of undefined behavior that cannot be caught this way. <a href="https://blog.regehr.org/archives/140">"C Compilers Disprove Fermat's Last Theorem"</a> is an excellent article that details the dangers of the offending clause in C11 and C99.</p>
<p>Although we can't eliminate all undefined behavior, doing the bare minimum to fix dereferences, alignment, overflow, underflow, and division by zero is a significant step in the right direction.</p>
<p><br></p>
<h2 id="fixing-undefined-behavior">Fixing undefined behavior:</h2>
<p>Let's write a header to fix our favorite arithmetic operations.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">/* WrapOverflow.h */</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#ifndef WRAP_OVERFLOW_INCLUDED</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#define WRAP_OVERFLOW_INCLUDED</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="pp">#ifndef WRAP_OVERFLOW</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="pp">#define WRAP_OVERFLOW 1</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="pp">#endif</span></span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="pp">#if WRAP_OVERFLOW</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="pp">#define PANIC()                                \</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="pp">    do {                                       \</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="pp">        puts(&quot;UNDEFINED BEHAVIOR, ABORTING.&quot;); \</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="pp">        exit(1);                               \</span></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="pp">    } while (0)</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="pp">#else</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="pp">#define PANIC() (void)0</span></span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="pp">#endif</span></span>
<span id="cb4-22"><a href="#cb4-22"></a></span>
<span id="cb4-23"><a href="#cb4-23"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>add(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb4-25"><a href="#cb4-25"></a>    <span class="cf">if</span> ((a &gt; <span class="dv">0</span>) &amp;&amp; (b &gt; INT_MAX - a)) PANIC(); <span class="co">// Overflow</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="cf">if</span> ((a &lt; <span class="dv">0</span>) &amp;&amp; (b &lt; INT_MIN - a)) PANIC(); <span class="co">// Underflow</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>    <span class="cf">return</span> a + b;</span>
<span id="cb4-28"><a href="#cb4-28"></a>}</span>
<span id="cb4-29"><a href="#cb4-29"></a></span>
<span id="cb4-30"><a href="#cb4-30"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb4-31"><a href="#cb4-31"></a>sub(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb4-32"><a href="#cb4-32"></a>    <span class="cf">if</span> ((b &lt; <span class="dv">0</span>) &amp;&amp; (a &gt; INT_MAX + b)) PANIC(); <span class="co">// Overflow</span></span>
<span id="cb4-33"><a href="#cb4-33"></a>    <span class="cf">if</span> ((b &gt; <span class="dv">0</span>) &amp;&amp; (a &lt; INT_MIN + b)) PANIC(); <span class="co">// Underflow</span></span>
<span id="cb4-34"><a href="#cb4-34"></a>    <span class="cf">return</span> a - b;</span>
<span id="cb4-35"><a href="#cb4-35"></a>}</span>
<span id="cb4-36"><a href="#cb4-36"></a></span>
<span id="cb4-37"><a href="#cb4-37"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb4-38"><a href="#cb4-38"></a>mult(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb4-39"><a href="#cb4-39"></a>    <span class="cf">if</span> ((b != <span class="dv">0</span>) &amp;&amp; (a &gt; INT_MAX / b)) PANIC(); <span class="co">// Overflow</span></span>
<span id="cb4-40"><a href="#cb4-40"></a>    <span class="cf">if</span> ((b != <span class="dv">0</span>) &amp;&amp; (a &lt; INT_MIN / b)) PANIC(); <span class="co">// Underflow</span></span>
<span id="cb4-41"><a href="#cb4-41"></a>    <span class="cf">return</span> a * b;</span>
<span id="cb4-42"><a href="#cb4-42"></a>}</span>
<span id="cb4-43"><a href="#cb4-43"></a></span>
<span id="cb4-44"><a href="#cb4-44"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb4-45"><a href="#cb4-45"></a>divide(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb4-46"><a href="#cb4-46"></a>    <span class="co">/* Division cannot overflow or underflow. */</span></span>
<span id="cb4-47"><a href="#cb4-47"></a>    <span class="cf">if</span> (b) PANIC(); <span class="co">// Division by zero</span></span>
<span id="cb4-48"><a href="#cb4-48"></a>    <span class="cf">return</span> a / b;</span>
<span id="cb4-49"><a href="#cb4-49"></a>}</span>
<span id="cb4-50"><a href="#cb4-50"></a></span>
<span id="cb4-51"><a href="#cb4-51"></a><span class="pp">#endif </span><span class="co">/* WRAP_OVERFLOW_INCLUDED */</span></span></code></pre></div>
<p>Obviously, with <code>WRAP_OVERFLOW</code> on, this will slow the code down. However, it will potentially save you hours of debugging.</p>
<h2 id="going-a-little-further">Going a little further:</h2>
<p>Daisho takes a similar approach to the header above. However, it uses GCC/Clang builtins to perform the check when available, and also wraps the overflow/underflow of unsigned integers as well. This has two benefits.</p>
<p>The first benefit is that while unsigned arithmetic wrapping is not undefined behavior, it can often be unintended (incorrect) behavior. The benefits to debugging with wrapped unsigned integers are exactly the same as wrapped signed integers.</p>
<p>The benefit is the ability to force unsigned overflow to become undefined behavior. This has performance benefits. The clang static optimizer in particular is very good at optimizing with undefined wrapping for unsigned arithmetic. Inside the optimizer, it applies attributes to each value (result of an expression). Integers with undefined unsigned wrapping semantics have their own attribute, <code>nuw</code> (no unsigned wrap). The LLVM IR emitted by clang for the following function returns such a value, and optimizes away the checks.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#define PANIC() __builtin_unreachable()</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">unsigned</span> <span class="dt">int</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>add_unsigned(<span class="dt">unsigned</span> <span class="dt">int</span> a, <span class="dt">unsigned</span> <span class="dt">int</span> b) {</span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="cf">if</span> (b &gt; UINT_MAX - a) PANIC(); <span class="co">// Overflow</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="cf">return</span> a + b;</span>
<span id="cb5-9"><a href="#cb5-9"></a>}</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">unsigned</span> <span class="dt">int</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>sub_unsigned(<span class="dt">unsigned</span> <span class="dt">int</span> a, <span class="dt">unsigned</span> <span class="dt">int</span> b) {</span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="cf">if</span> (a &lt; b) PANIC(); <span class="co">// Underflow</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="cf">return</span> a - b;</span>
<span id="cb5-15"><a href="#cb5-15"></a>}</span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">unsigned</span> <span class="dt">int</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>mult_unsigned(<span class="dt">unsigned</span> <span class="dt">int</span> a, <span class="dt">unsigned</span> <span class="dt">int</span> b) {</span>
<span id="cb5-19"><a href="#cb5-19"></a>    <span class="cf">if</span> ((b != <span class="dv">0</span>) &amp;&amp; (a &gt; UINT_MAX / b)) PANIC(); <span class="co">// Overflow</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="cf">return</span> a * b;</span>
<span id="cb5-21"><a href="#cb5-21"></a>}</span>
<span id="cb5-22"><a href="#cb5-22"></a></span>
<span id="cb5-23"><a href="#cb5-23"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">unsigned</span> <span class="dt">int</span></span>
<span id="cb5-24"><a href="#cb5-24"></a>divide_unsigned(<span class="dt">unsigned</span> <span class="dt">int</span> a, <span class="dt">unsigned</span> <span class="dt">int</span> b) {</span>
<span id="cb5-25"><a href="#cb5-25"></a>    <span class="cf">if</span> (!b) PANIC(); <span class="co">// Division by zero</span></span>
<span id="cb5-26"><a href="#cb5-26"></a>    <span class="cf">return</span> a / b;</span>
<span id="cb5-27"><a href="#cb5-27"></a>}</span></code></pre></div>
<p>The Daisho compiler generates something similar to the above at <code>--insane</code> optimization level. Otherwise it takes the same approach as the header above for signed integers. However, it provides much more information to help you debug. It aborts the program for you, letting you know exactly where the precondition was violated, with what values, on what line, in what file.</p>
<p>The same approach is being taken to wrap every dereference and every bit shift.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>is_aligned(<span class="dt">const</span> <span class="dt">void</span>* pointer, <span class="dt">size_t</span> to) {</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="cf">return</span> (<span class="dt">uintptr_t</span>)pointer % to == <span class="dv">0</span>;</span>
<span id="cb6-4"><a href="#cb6-4"></a>}</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>deref_int(<span class="dt">int</span> *to_deref) {</span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="cf">if</span> (!to_deref) PANIC(); <span class="co">// Null pointer</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="cf">if</span> (!is_aligned(to_deref, <span class="kw">_Alignof</span>(<span class="dt">int</span>))) PANIC(); <span class="co">// Misaligned pointer</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="cf">return</span> *to_deref;</span>
<span id="cb6-11"><a href="#cb6-11"></a>}</span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>right_shift(<span class="dt">int</span> to_shift, <span class="dt">int</span> by) {</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="cf">if</span> (by &lt; <span class="dv">0</span>) PANIC(); <span class="co">// Negative shift</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="cf">if</span> (by &gt; (CHAR_BIT * <span class="kw">sizeof</span>(<span class="dt">int</span>))) PANIC(); <span class="co">// Oversize shift</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>    <span class="cf">return</span> to_shift &gt;&gt; by;</span>
<span id="cb6-18"><a href="#cb6-18"></a>}</span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>left_shift(<span class="dt">int</span> to_shift, <span class="dt">int</span> by) {</span>
<span id="cb6-22"><a href="#cb6-22"></a>    <span class="cf">if</span> (by &lt; <span class="dv">0</span>) PANIC(); <span class="co">// Negative shift</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="cf">if</span> (by &gt; (CHAR_BIT * <span class="kw">sizeof</span>(<span class="dt">int</span>))) PANIC(); <span class="co">// Oversize shift</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>    <span class="cf">return</span> to_shift &lt;&lt; by;</span>
<span id="cb6-25"><a href="#cb6-25"></a>}</span></code></pre></div>
<p>The conversion of every pointer type to <code>void*</code> is intentional and important. On some platforms that might not be a no-op, and <code>uintptr_t</code> is only technically guaranteed to be compatible with <code>void*.</code> This is yet another excruciatingly painful dark corner of the standard. In my opinion, compilers should complain when you cast any other pointer type <code>intptr_t</code> or <code>uintptr_t</code>, and tell you to cast first. They should, but they don't.</p>
<p>The other important thing that the Daisho code generator does to help you is write unambiguous code. Another sharp corner of the standard is that a variable should not be updated more than once between sequence points.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">int</span> x = <span class="dv">1</span>;</span>
<span id="cb7-2"><a href="#cb7-2"></a>x = ++x; <span class="co">// Undefined behavior.</span></span></code></pre></div>
<p>It's fairly easy for a human to accidentally write this, especially when they don't know about this quirk. However, the Daisho compiler will not. It orders every operation (including the unspecified behavior of evaluation order inside of calls, for example), and puts it onto its own line in its own statement.</p>
<p>Once it's done, if you find that the Daisho compiler (<code>daic</code>) generates code with UB, please file a bug report.</p>
<p><br></p>
<h2 id="going-above-and-beyond">Going above and beyond:</h2>
<p>Here's a list of extreme things that tooling could do to improve the safety and correctness of C code.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode md"><code class="sourceCode markdown"><span id="cb8-1"><a href="#cb8-1"></a><span class="ss">* </span>Memory boundary tracking analysis (like address sanitizer)</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ss">* </span>Stack unwinding backtraces (already implemented in Daisho)</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ss">* </span>Data race detection (like thread sanitizer)</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ss">* </span>Automatic fuzzing and testing framework</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="ss">* </span>Syntax for enforcing preconditions and postconditions</span></code></pre></div>
<p>I plan on eventually implementing every item in this list but the last one. However, they are not a priority. The first priority is going to be having a working compiler.</p>
<p>I think the last option is by far the most extreme. There's the potential here to reorient the entire way we look at safety and correctness. Even if the implementation is just "Fancy assert syntax and a theorem prover." The idea is that everything that can be statically analyzed by the prover to be safe and correct (as defined above) will be asserted at compile time, and everything that can't be will be moved to runtime. This will have tremendous runtime costs while you're debugging, but will lead to faster code for production and less human time spent chasing safety and correctness issues.</p>
<p>That's the hope anyway.</p>
<p><br></p>
<h2 id="rediscovering-an-old-way-of-writing-software">Rediscovering an old way of writing software</h2>
<p>Ada is an interesting case study. It has range-based types, with runtime range checks. In the airplane firmware space, we know its benefits well. Throwing runtime checks at everything protects against memory corruption caused by cosmic radiation.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ada"><code class="sourceCode ada"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">procedure</span> Main <span class="kw">is</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>   <span class="kw">type</span> Grade <span class="kw">is</span> <span class="kw">range</span> <span class="dv">0</span> .. <span class="dv">100</span>;</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>   G1, G2  : Grade;</span>
<span id="cb9-5"><a href="#cb9-5"></a>   N       : <span class="dt">Integer</span>;</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">begin</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>   ...                <span class="co">-- Initialization of N</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>   G1 := <span class="dv">80</span>;          <span class="co">-- OK</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>   G1 := N;           <span class="co">-- Illegal (type mismatch)</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>   G1 := Grade (N);   <span class="co">-- Legal, run-time range check</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>   G2 := G1 + <span class="dv">10</span>;     <span class="co">-- Legal, run-time range check</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>   G1 := (G1 + G2)/<span class="dv">2</span>; <span class="co">-- Legal, run-time range check</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">end</span> Main;</span></code></pre></div>
<p>For safety's sake, the <code>Grade</code> type does what we want it to. It's protected against overflow and underflow. It's "safe," and that safety does lead to real safety benefits in the real world for actual human beings on any of the thousands of planes currently in the air at this very moment.</p>
<p>But it's a little bit unsatisfactory for me. I think we could do more. Imagine a type system like the following.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>range&lt;-<span class="dv">50</span>, <span class="dv">100</span>&gt; range_add(range&lt;-<span class="dv">50</span>, <span class="dv">50</span>&gt; a, range&lt;<span class="dv">0</span>, <span class="dv">50</span>&gt; b) {</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="cf">return</span> a + b;</span>
<span id="cb10-3"><a href="#cb10-3"></a>}</span></code></pre></div>
<p>Let the result of arithmetic with two ranges be the mathematical range of the outputs given the domains. Now let the compiler automatically deduce it.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">auto</span> range_add(<span class="kw">auto</span> a, <span class="kw">auto</span> b) {</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="cf">return</span> a + b;</span>
<span id="cb11-3"><a href="#cb11-3"></a>}</span></code></pre></div>
<p>Now, disallow any sort of operation that could potentially break. Make them check for it and coerce the ranges back.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">auto</span> a = INT_MAX + <span class="dv">1</span> <span class="co">// Compile error, return type would overflow</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>range&lt;<span class="dv">0</span>, <span class="dv">50</span>&gt; b = <span class="dv">5</span>;</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">auto</span> x = <span class="dv">20</span> / b; <span class="co">// Compile error, b could be 0.</span></span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a>range&lt;<span class="dv">1</span>, <span class="dv">50</span>&gt; c = coerce(b != <span class="dv">0</span>);</span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">auto</span> y = <span class="dv">20</span> / c; <span class="co">// Works, c cannot be 0.</span></span></code></pre></div>
<p>This is of course a difficult to implement mess of dependently typed nonsense. It's also not exactly a great time to use. I think the approach has a lot of potential in the safety-critical software domain. However, this industry is very averse to change. Realistically, even though it's a good idea, it's never going to happen.</p>
<p>Rest assured, Daisho will not be doing this.</p>
<p><br></p>
<h2 id="conclusion">Conclusion</h2>
<p>Safety is the absence of undefined behavior. Correctness is that your program is fully specified and fully conforms to that specification in all cases, including the ones you haven't thought of. Preconditions and postconditions are the specification. A bug is a lapse in correctness due to a mistake in the implementation of the preconditions and postconditions.</p>
<p>As you can see, the C standard is broken in a lot of obscure ways. Undefined behavior (as well as implementation-defined and unspecified behaviors) are great for enabling compiler optimizations, and making writing C compilers easier to write or port by eliminating corner cases, but push the corner cases onto the programmer. Debugging this stuff can be purgatory. It shouldn't have to be this way.</p>
<p>Tooling can solve a lot of these issues. It doesn't technically have to be a whole new programming language. It could just be AST transformations on a C frontend that turn all your <code>+</code> operators to <code>add(a, b)</code>, your <code>&lt;&lt;</code> to <code>left_shift(to_shift, by)</code>, etc. Or you could do it by hand. Or you can just stare at the screen. That's what most people do, but I think we need a better option.</p>
<p>When I started implementing this strategy, my debugging efficiency went up considerably. Suddenly, I could tell why large sections of my code were being optimized away. It's hard to debug code that doesn't exist, and wrapping common sources of UB lets me keep it around so I can get an error.</p>
<p>There's also the nuclear option. You could redefine your entire type system around not allowing undefined operations. It's not exactly an ergonomic option, but it's an option.</p>
<p>The biggest blunder you could make would be to mistake safety for correctness. Just because unsigned wrapping is safe (defined) in C doesn't mean that it isn't usually wrong. It's safe by the definition above, but in safety critical software it's very dangerous. Many people have died as a result of unintentional integer overflow and underflow.</p>
<p>Whether you program in C, C++, or another language without undefined behavior doesn't matter. You still have to think about these things. You are not immune.</p>
<p>For Daisho, I have decided that I want to wrap and eliminate all the undefined behavior that I can. It makes the program slower, but saves me time. Then, once the program is tested, I turn optimizations back on. The operations are undefined, the compiler is free to optimize aggressively, and all the speed returns. When I need to, I use <code>objdump</code> to check the code that's generated for missing sections and opportunities for optimization.</p>
<p>In any case, people have been complaining about undefined behavior since the 90s. It's about time that people either got comfortable with it or started doing something about it.</p>
<p><br></p>
</body>
</html>
