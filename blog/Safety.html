<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Safety</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
  /* https://github.com/markdowncss/retro/blob/master/css/retro.css */

  @font-face {
      font-family: "lemon";
      src: url('lemon.woff');
  }

  /*
  @media print {
      *, *:before, *:after {
          background: transparent !important;
          color: #000 !important;
          box-shadow: none !important;
          text-shadow: none !important;
      }
      a, a:visited { text-decoration: underline; }
      a[href]:after { content: " (" attr(href) ")"; }
      abbr[title]:after { content: " (" attr(title) ")"; }
      a[href^="#"]:after, a[href^="javascript:"]:after { content: ""; }
      pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
      thead { display: table-header-group; }
      tr, img { page-break-inside: avoid; }
      img { max-width: 100% !important; }
      p, h2, h3 { orphans: 3; widows: 3; }
      h2, h3 { page-break-after: avoid; }
  }
  */
  a, a:visited { color: #01ff70; }
  a:hover, a:focus, a:active { color: #2ecc40; }
  .retro-no-decoration { text-decoration: none; }
  p, .retro-p {
      font-size: 1rem;
      margin-bottom: 1.3rem;
      /*text-indent: 50px*/
  }
  h1, .retro-h1, h2, .retro-h2, h3, .retro-h3, h4, .retro-h4 {
      margin: 1.414rem 0 .5rem;
      font-weight: inherit;
      line-height: 1.42;
  }
  h1, .retro-h1 {
      color: rgb(112, 221, 0);
      margin-top: 0;
      font-size: 3.998rem;
  }
  h2, .retro-h2 {
      color: rgb(112, 221, 0);
      margin-top: 0;
      font-size: 2.827rem;
  }
  h3, .retro-h3 {
      font-size: 1.999rem;
  }
  h4, .retro-h4 {
      font-size: 1.414rem;
  }
  h5, .retro-h5 {
      font-size: 1.121rem;
  }
  h6, .retro-h6 {
      font-size: .88rem;
  }
  small, .retro-small {
      font-size: .707em;
  }

  img, canvas, iframe, video, svg, select, textarea { max-width: 100%; }

  html, body {
      /* background-image: url(https://raw.githubusercontent.com/apaz-cli/apaz-cli.github.io/master/pattern.png); */
      background-color: #222;
      min-height: 100%;
      font-size: 20px;
  }
  body {
      color: #fafafa;
      font-family: "lemon", "Courier New";
      line-height: 1.65;
      margin: 6rem auto 1rem;
      max-width: 48rem;
      /* padding: .25rem; */
  }
  pre, code {
      background-color: #333;
      font-family: "lemon", "Menlo", "Monaco", "Courier New";
      font-size: 12;
  }

  code span.dt { color: #e4a51e; } /* DataType */

  pre {
      padding: .5rem;
      line-height: 1.25;
      overflow-x: scroll;
  }
  blockquote {
      border-left: 3px solid #01ff70;
      padding-left: 1rem;
  }
  </style>
</head>
<body>
<h1 id="safety-and-correctness">Safety and Correctness</h1>
<p>Everybody who writes airplane firmware has their own opinion about how to achieve "safety." Yet, nobody that I work with really knows what that means. It's a lofty, but poorly defined goal.</p>
<p><img src="images/PlaneClouds_skyrick9413.jpg" /></p>
<p>Luckily, the vast majority of airplane firmware hasn't killed people. Not killing anybody is admirable, but still not actionable enough to be useful. The <a href="https://en.wikipedia.org/wiki/MISRA_C">MISRA C</a> standards are good, and <a href="https://en.wikipedia.org/wiki/DO-178C">DO-178C</a> does guarantee a minimum level of safety through sheer amount of expensive documentation and testing effort, but both standards leave much to be desired. I'm left wondering what it is we're all chasing.</p>
<p>Today, I watched a CPPCon talk that unified everything I know on the topic. The talk is about <code>std::find()</code> and <code>std::find_if()</code> from C++, but the points that it made along the way are what resonated with me. It brought together my experiences designing a Java perceptual image processing research library, and my time spent designing, writing, debugging, and verifying engine controller and weapons systems firmware in C. Honestly, I wish it all clicked sooner.</p>
<p>This post is written about C and C++, but using other languages does not excuse you from having to think about these things. The common phrase that people use is "just because the language is safe, that doesn't mean the code you wrote is correct." Now I have a way to express what that means.</p>
<p>This new perspective presents an interesting and actionable path forward for the tooling surrounding Daisho and other programming languages. It may also solve some unique challenges inside the C portion of the Daisho standard library, as well as the age-old problem of what to do about a specific class of dangerous and difficult to track down UB bugs coming from problems like signed integer overflow, oversize shifts, and division by zero.</p>
<p><br></p>
<h2 id="the-video">The Video:</h2>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/2FAi2mNYjFA?start=1430" title="YouTube video player" frameborder="0" allow="encrypted-media; picture-in-picture" align="center " allowfullscreen>
</iframe>
</center>
<p><br></p>
<h2 id="definitions">Definitions</h2>
<h3 id="preconditions-and-postconditions">Preconditions and Postconditions</h3>
<p><a href="https://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a> describes computations as a Hoare triple <code>{P}C{Q}</code> where <code>P</code> is assertions about preconditions, <code>Q</code> is assertions about postconditions, and <code>C</code> is the code being described.</p>
<p>Even when we're not conciously trying, odds are that we already think about functions as having preconditions and postconditions. If your code is well written, composed primarily of functions, and those functions are well named, then odds are that you have a good idea what your preconditions are. But, you probably don't know exactly what they are. In fact, you almost definitely don't. Specifying the preconditions and postconditions of parts of your program can be an iterative process. You can design them up front, but the implementation of your code will almost certainly introduce new ones.</p>
<p>In the aerospace industry, we are forced to think in terms of preconditions and postconditions. It's the nature of requirements based development, which is mandated by the FAA. However, we are forced to think about them from a requirements level, rather than an implementation level. The expectation is that the implementation is left up to the software engineer, and its correctness will come out in code review. The remainder of this post deals with the implementation level, not the requirements level.</p>
<h3 id="safety">Safety:</h3>
<p>An operation is safe if it cannot lead to undefined behavior, either directly or indirectly, even if the operation's preconditions are violated. An operation that is unsafe can lead to undefined behavior if its preconditions are violated.</p>
<p>Safety only specifies whether every possible set of preconditions maps to a postcondition. It has nothing to do with how many bugs your program has, only what happens when unexpected conditions occur.</p>
<h3 id="correctness">Correctness:</h3>
<p>An operation that is correct satisfies the intended postconditions if its preconditions are satisfied.</p>
<p>If the preconditions of a safe correct operation are not met, the result is unspecified (but defined). If the preconditions of an unsafe correct operations are not met, the result is undefined or unspecified.</p>
<p><br></p>
<h2 id="why-do-we-write-unsafe-programs">Why do we write unsafe programs?</h2>
<p>Undefined Behavior introduces silent preconditions that are hard to detect and reason about. Is the following code safe? Stare at it for a while.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dt">char</span> strDeref(<span class="dt">const</span> <span class="dt">char</span> *str, <span class="dt">int</span> idx1, <span class="dt">int</span> idx2) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="cf">if</span> (str == NULL)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="cf">if</span> ((idx1 + idx2) &lt; <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  <span class="cf">if</span> (strnlen(str, <span class="dv">1000</span>) &lt;= (idx1 + idx2))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>  <span class="cf">return</span> str[idx1 + idx2];</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>I would say that it sure looks right. But that's not what safe means.</p>
<p>Even if you think you're covering all of your bases by checking the length of the string, and even using <code>strnlen()</code> over <code>strlen()</code> to do so because it's "safer" (it isn't), it's very hard to make sure your API is safe. The problem is <code>idx1 + idx2</code>. Signed integer overflow is undefined. So are a lot of other things. Truly safe code is difficult to acheive. Or it's literally impossible in some (most) cases. There are some other UB problems that can be fixed this way as well, just by checking. Oversize shift amounts and pointer alignment fall into this category.</p>
<p>Let's fix the above example.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">char</span> strDeref(<span class="dt">const</span> <span class="dt">char</span> *str, <span class="dt">int</span> idx1, <span class="dt">int</span> idx2) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="cf">if</span> ((idx1 &gt; <span class="dv">0</span> &amp;&amp; idx2 &gt; INT_MAX - idx1)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>   || (idx1 &lt; <span class="dv">0</span> &amp;&amp; idx2 &lt; INT_MIN - idx1))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="co">/* str is aligned, since char* has no alignment requirements. */</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span class="cf">if</span> (str == NULL)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>  <span class="cf">if</span> ((idx1 + idx2) &lt; <span class="dv">0</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>  <span class="cf">if</span> (strnlen(str, <span class="dv">1000</span>) &lt;= (idx1 + idx2))</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>    <span class="cf">return</span> <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>  <span class="cf">return</span> str[idx1 + idx2];</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>}</span></code></pre></div>
<p>Surely now it's safe for any possible preconditions, right? I raise you the following.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>strDeref((<span class="dt">char</span> *)(<span class="dt">intptr_t</span>)<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>);</span></code></pre></div>
<p>Checking whether a memory region is valid is very difficult. It seems at this point that we're out of luck. We can't (reasonably) fix this. It's doable theoretically, but would require so much instrumentation that it would be easier just to buy the whole orchestra.</p>
<p>Luckily, people don't often write code like this that's so obviously wrong. We know that dereferencing a wild pointer (one that isn't aligned inside of a valid memory region) is bad. But there are less obvious ways to obtain a pointer to an invalid memory region. We've covered the null pointer case, but there's also use after free. Unless we can guarantee that <code>str</code> is valid and aligned, we cannot call this function safely. It could cause undefined behavior by dereferencing that pointer, which is unfortunately the entire point of the function.</p>
<p>From a language design perspective, it doesn't have to be this way. What if the creation of that pointer was the undefined behavior? What if obtaining such a pointer were impossible? What should the programming language's role in this be? We'll get to my opinions on that later.</p>
<p>The code above is unsafe. But notably, it is not incorrect. I think we can agree that, even without all the checks, it does what you want it to for all sensible inputs. What exactly constitutes a "sensible input" is what we have to define here. Most programmers do not define their preconditions, and instead rely on tacit knowledge. We know that passing an invalid pointer probably violates some preconditions, so we don't. When we want to add two numbers, we don't think about the domain of the inputs. We also don't think to document that the behavior of our function is undefined if <code>((a &gt; 0 &amp;&amp; b &gt; INT_MAX - a) || (a &lt; 0 &amp;&amp; b &lt; INT_MIN - a))</code>. Instead, we just document the operation that is supposed to be performed and go by feel. This is true even in the airplane firmware world.</p>
<p>What's above is just a simple example. We have our definition, but with respect to our current practice of fuzzy preconditions, what does "correct" mean? Our definition assumes preconditions and postconditions are well defined. How APIs compose with respect to preconditions and postconditions gets progressively more difficult to reason about. Once your codebase approaches a certain size, it's anyone's guess.</p>
<p><br></p>
<h2 id="kinds-of-errors">Kinds of Errors:</h2>
<p>I assert that there are a few categories of errors.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode md"><code class="sourceCode markdown"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ss">1. </span>Is the error recoverable?</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="ss">2. </span>Did the error come from violating a precondition?</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ss">3. </span>Did you plan for this error?</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="ss">4. </span>Is the cause of the error beyond your control?</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="ss">5. </span>Is the behavior undefined?</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode md"><code class="sourceCode markdown"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="an">Examples:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>10100 - <span class="in">`malloc()`</span> fails, and an error is returned to the caller.</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>01001 - Accidentally passed a null pointer to <span class="in">`strlen()`</span>.</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>00011 - The CPU is hit with a big hammer.</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>10110 - One of your CPUs is hit with a big hammer, but you&#39;re writing airplane firmware.</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>01000 - While debugging, you instrumented the build of your code to trap on integer overflow.</span></code></pre></div>
<p>As you can see, there are many kinds of errors. For any given combination of yes/no answers, you could probably come up with your own example.</p>
<p>Although there are lots of types of errors, once one error has been detected, there are really only two things things you want to do with it. You either pass the error to the caller, or you crash, hopefully as gracefully as possible.</p>
<p><br></p>
<h2 id="how-can-our-tooling-help">How can our tooling help?</h2>
<h2 id="actionable-advice-about-safety">Actionable Advice About Safety:</h2>
</body>
</html>
