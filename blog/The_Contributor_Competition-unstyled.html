<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The Contributor Competition</title>
</head>
<body>
<h1 id="the-contributor-competition">The Contributor Competition</h1>
<p><br></p>
<div style="text-align: center;">
<p><img src="images/ruin_sword.jpg" /></p>
</div>
<h4
id="open-source-projects-compete-for-contributors.-how-can-you-win">Open
source projects compete for contributors. How can you win?</h4>
<hr>
<h2 id="a-case-study.">A case study.</h2>
<hr>
<p>    Python and Julia are programming languages that fill a very
similar niche. They're both dynamic scripting languages popular in the
scientific computing space. People use them to replace Matlab and R. Why
is Julia languishing, while Python is flourishing?</p>
<br>
<div style="text-align: center;">
<p><img src="images/Python_vs_Julia.png" /></p>
</div>
<p><br></p>
<p>    Julia has been relatively successful at attracting users. Most CS
students that I went to college with learned Julia. But very few have
been convinced to become contributors. I was curious, so I looked at the
recent PRs. I was looking for a PR from someone not in the Julia
programming language organization. I found one. It was the 63rd PR I
looked at. A prolific contributor who wasn't technically in the
organization, but had contributed all over the Julia package ecosystem.
I scrolled through a few more pages, but couldn't find a name that I
didn't recognize. The Julia community is very tight-knit and
insular.</p>
<p>    I did the same for Python. The fourth PR from the top was a first
time contributor. The Julia organization on Github has 187 members.
Python has by far more users, but only 129 members. Anyway, this is
circumstantial evidence that doesn't prove anything. But something is
going on here.</p>
<p>    No language is "better" than another. Usually these comparisons
are an excercise in tribalism. But bear with me here. Let's look at only
the technology. In a vaccum, Julia just seems "better" than Python.</p>
<p>    It's faster. It automatically deduces types, then uses them to
jit compile using LLVM ORC. You can compile a function and read the
assembly. It has perhaps (tied with ipython) the best REPL in the world,
built into the base language. It solves the <a
href="https://en.wikipedia.org/wiki/Expression_problem">expression
problem</a>, which python cannot. It has a more principled package
manager. You can run Julia code on the GPU. The compiler is extensible.
Very fancy. It's a complex and incredible marvel of engineering. It has
everything going for it, from a technical perspective.</p>
<p>    Why, then, does Julia not attract contributors? Surely all of
that should make people want to work on it, right?</p>
<h2 id="the-problem">The problem</h2>
<hr>
<p>    Yeah, no. here's the problem. None of that matters. Nobody
cares.</p>
<p>    Fundamentally, what contributors want is to solve their own
problems and optimize their own experience. They are selfish. They think
about how to use the project to accomplish their own goals. They don't
care about the maintainer's problems as much as the maintainer may hope.
Especially if they cannot at a glance understand those problems. Julia
is too complicated to contribute to without sacrifice. I know, because I
have sacrificed.</p>
<p>    Potential contributors may support your mission, but they won't
sacrifice anything for it. They have a very short attention span. They
want to contribute so that they can avoid pain, not take on more pain.
If they can't immediately solve their problem, they will leave. They'll
find a workaround without upstreaming a fix, or they will just find some
other project. The only way to get someone to sacrifice for your cause
is to pay them, or offer some other incentive. Nobody wants to clean up
your mess for you.</p>
<p>    I consider Julia to be a cautionary tale. I've had multiple
conversations with the maintainers to the effect of "We have a long list
of good first issues, why is nobody picking them up? We have like three
hundred of them! Fix our type inference bugs! Debug our segfaults! Why
are there no new contributors?" They forget that nobody wants to do
that. People have their own problems to deal with.</p>
<h2 id="the-solution">The Solution</h2>
<hr>
<p>    The solution is to drastically lower the barrier to entry while
making the project as useful as possible. That way, useful contributions
to your project will not require much sacrifice. The risk (wasted time)
vs reward (features merged) calculation becomes more favorable. Then
maybe some of those short term contributors will keep using your project
and turn into long term contributors and maintainers. People that you
can design new features with, who can review your code and point out
conceptual issues.</p>
<p>    It's actually not enough to lower the barrier to entry. You need
to make sure that people know that it's low. This is more important than
it actually being low. Frequent communication is key. If people know
that they can go on discord for help implementing a feature and expect
that it will be approved and merged within a day, then who wouldn't want
to contribute? But if you need to find someone willing to review your PR
and you haven't already befriended a maintainer, and you're not sure if
you can even understand the code in the first place, then maybe not.</p>
<p>TODO: Write about empowering contributors to make the project their
own.</p>
<h1 id="actionable-advice.">Actionable advice.</h1>
<hr>
<ol type="1">
<li><p>Automated testing is a must. Write good, exhaustive tests so that
contributors can be confident that their features and fixes don't cause
regressions elsewhere. Equally important, write up a guide on how run
tests and add tests, and place this guide somewhere prominent. This
should be as frictionless as possible.</p></li>
<li><p>Document anything that would not be immediately understandable by
a layperson. As a Julia example, nobody without a Master's degree in
compiler engineering is going to understand what a phi node or a
dominance frontier is. If you want contributors, then this is
unacceptable. At very least, point to resources that can be consumed in
&lt; 15 minutes.</p></li>
<li><p>APIs should be self documenting, but you should document them
anyway. Exhaustively. You can do this with LLMs, they're very good at
it. If it's python, add type annotations. Not as a tool for
communicating with a type checked, but as a rule for communicating with
humans. It makes the code more readable. I find myself spending a long
time figuring out all the different places a function could be called
from so that I can figure out its types. The better solution is to just
put it there.</p></li>
<li><p>Set up a Discord server. Be active there answering questions.
Think of this time investment as an investment. More people will arrive
later with the same question.</p></li>
<li><p>Acknowledge and appreciate contributions. Doesn't matter how
large or small. You want contributing to your project to feel good. Make
sure they feel proud of their work. This too is an investment.</p></li>
</ol>
<p><br></p>
</body>
</html>
