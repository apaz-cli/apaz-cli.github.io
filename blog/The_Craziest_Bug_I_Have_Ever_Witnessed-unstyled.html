<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The Craziest Bug I Have Ever Witnessed</title>
</head>
<body>
<div style="text-align: center;">
<p><img src="images/MessyRoom_arsenixc.jpg" /></p>
</div>
<h1 id="the-craziest-bug-i-have-ever-witnessed">The Craziest Bug I Have
Ever Witnessed</h1>
<p>Julia has a feature where you can report bugs and crashes from the
command line. You just run your program with
<code>julia --bug-report=rr</code>, and it sends a crash report plus an
<code>rr</code> trace of the process to our servers for us to take a
look at.</p>
<div style="text-align: center;">
<p><img src="images/rr-meme.jpeg" alt="rr-meme" /> <br> This is Keno's
meme, and I have unabashedly stolen it.</p>
</div>
<p>Sometimes we get some crazy stuff. This is in fact not the first time
that someone from the Julia team has found something crazy in a crash
dump. Keno wrote a similar (and substantially more detailed) article <a
href="https://julialang.org/blog/2020/09/rr-memory-magic/">here</a>,
where he used <code>rr</code> to debug a process where the issue turned
out to be faulty memory.</p>
<p>Where Keno visually detailed how he found the bug, I'm just going to
rant from memory. I wish that I had kept better records. Live and
learn.</p>
<h2 id="the-crash">The Crash</h2>
<p>Julia is a dynamically dispatched and garbage collected language. The
bug manifested itself as a random crash in function dispatch inside the
interpreter, which is also written in Julia. The function dispatch code
is well tested. When the interpreter crashes, it's generally the case
that there was already memory corruption.</p>
<p>These sorts of bugs generally suck to find. When you're writing C,
you can usually just compile with <code>-fsanitize=address</code>.
Address Sanitizer will tell you when you overwrite memory that doesn't
belong to any known variable. Unfortunately, the Julia runtime doesn't
support being compiled with asan because it depends on third party
binaries that were <em>not</em> compiled with asan. This means that when
our binary reaches into memory allocated for variables in those
libraries, asan will throw a false positive and crash. When one part of
the process is compiled with asan, it all must be.</p>
<h2 id="finding-the-bug">Finding The Bug</h2>
<p>Without msan as a crutch, I decided to do as my forebears did and
guess. I loaded up <code>rr</code>, typed <code>bt full</code>, and...
even after a while of gawking at it, this stack trace doesn't make any
sense. It very clearly doesn't follow the control flow of the source
code. Why?</p>
<p>Dispatch in Julia is dynamic. What must have happened is that either
a C function pointer or Julia object was written on top of another.
But... how? And where?</p>
<p>Reading through the backtrace, I found that the process crashed after
a <code>jl_call</code> to <code>abstract_invoke()</code>. That rules out
that a C function pointer is the culprit. We're looking for a Julia
object written on top of another.</p>
<p>I was still new to the Julia codebase at this point, so for a little
while I was stuck. I spent half an hour reading different parts of the
runtime that the process was touching. Nothing seemed to pop out at me.
Eventually I started reading the garbage collector, and the answer
seemed obvious.</p>
<p>When Julia objects are allocated, they are never relocated. They stay
there forever, until they are collected. Therefore, it is actualy
impossible that an object was written on top of another... unless it
happened in the garbage collector's allocator.</p>
<p>So, I set a breakpoint on <code>jl_gc_alloc()</code>, and
<code>jl_gc_sweep()</code> and watched the pointers that came out of the
allocator. Sure enough, <code>jl_gc_alloc()</code> returned the same
pointer twice before <code>jl_gc_sweep()</code>. That is not supposed to
happen. The question remains, why is it happening?</p>
<p>When I descended deeper, I found that <code>jl_gc_alloc()</code> just
calls <code>malloc()</code>, offsets the resulting pointer, and does a
bunch of bookkeeping, and it was actually <code>malloc()</code> that
returned the same thing twice.</p>
<p>... Excuse me, what?</p>
<p>I time travelled back and set a breakpoint on <code>free()</code>.
Nope. It isn't freed. Libc just straight up returned the same pointer
twice. What? How does that happen?</p>
<p>Collecting myself, I noted that there was an extra call to
<code>malloc()</code> between the two calls to
<code>jl_gc_alloc()</code>. What is that?</p>
<p>When I travelled to it and typed <code>bt</code> once more into
<code>rr</code>, I saw that call to <code>malloc()</code> happened on a
signal stack inside a call to <code>dlopen()</code>. Suddenly, I knew
exactly what the bug was and where.</p>
<h2 id="explaination">Explaination</h2>
<p>Most C programmers understand that the linker can do dynamic linking
for you. Few understand dynamic linking's perilous interaction with
signal handlers.</p>
<p>It doesn't help that signal safety is a difficult topic for beginners
to wrap their heads around in the first place.
<code>man signal-safety</code> is present, but doesn't do the topic
justice. The short version of the rant is that if a function is not on
the list of allowed functions from <code>man signal-safety</code>, do
not call it from a signal handler. If you do, then understand you are
doing so at your own peril. It is also against the rules to modify any
shared global state, or risk the same sort of corruption.</p>
<p>This is because when a signal handler executes it pauses the current
thread <em>wherever it is</em>. That is to say, suppose a thread calls
<code>malloc()</code> and is interrupted halfway through by a signal
handler. That signal handler then also calls <code>malloc()</code>.</p>
<p>It obviously isn't, but for simplicity's sake suppose that
<code>malloc()</code> is implemented something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> freelist<span class="op">[</span>FREELIST_SIZE<span class="op">];</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> freelist_size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free<span class="op">(</span><span class="dt">void</span><span class="op">*</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  freelist<span class="op">[</span>freelist_size<span class="op">++]</span> <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> malloc<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span><span class="op">*</span> ret <span class="op">=</span> freelist<span class="op">[</span>freelist_size <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* THREAD PAUSED HERE FOR SIGNAL HANDLER */</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">--</span>freelist_size<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In that circumstance, when the return value is decided and the thread
is paused before the bookkeeping completes, you can see how
<code>malloc()</code> would return the same thing twice. The same thing
happens inside glibc. It grabs a pointer from the freelist, but doesn't
completely erase the record of it in the same instruction. This can also
lead to the allocator getting corrupted.</p>
<p>What makes this bug so insidious is that people don't <em>know</em>
they are doing something unsafe by calling ostensibly signal-safe code
from a signal handler. The linker inserts a call to
<code>dlopen()</code>, and that's what calls <code>malloc()</code>. Two
hidden layers.</p>
</body>
</html>
