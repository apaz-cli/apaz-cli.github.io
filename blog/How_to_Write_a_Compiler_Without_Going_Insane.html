<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>How to Write a Compiler Without Going Insane</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
      font-size: 20px;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <style type="text/css">
  /* https://github.com/markdowncss/retro/blob/master/css/retro.css */

  @font-face {
      font-family: "lemon";
      src: url('lemon.woff');
  }

  /*
  @media print {
      *, *:before, *:after {
          background: transparent !important;
          color: #000 !important;
          box-shadow: none !important;
          text-shadow: none !important;
      }
      a, a:visited { text-decoration: underline; }
      a[href]:after { content: " (" attr(href) ")"; }
      abbr[title]:after { content: " (" attr(title) ")"; }
      a[href^="#"]:after, a[href^="javascript:"]:after { content: ""; }
      pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
      thead { display: table-header-group; }
      tr, img { page-break-inside: avoid; }
      img { max-width: 100% !important; }
      p, h2, h3 { orphans: 3; widows: 3; }
      h2, h3 { page-break-after: avoid; }
  }
  */
  a, a:visited { color: #01ff70; }
  a:hover, a:focus, a:active { color: #2ecc40; }
  .retro-no-decoration { text-decoration: none; }
  p, .retro-p {
      font-size: 1rem;
      margin-bottom: 1.3rem;
      /*text-indent: 50px*/
  }
  h1, .retro-h1, h2, .retro-h2, h3, .retro-h3, h4, .retro-h4 {
      font-family: "lemon";
      margin: 1.414rem 0 .5rem;
      font-weight: inherit;
      line-height: 1.42;
  }
  h1, .retro-h1 {
      color: rgb(112, 221, 0);
      margin-top: 0;
      font-size: 3.998rem;
  }
  h2, .retro-h2 {
      color: rgb(112, 221, 0);
      margin-top: 0;
      font-size: 2.827rem;
  }
  h3, .retro-h3 {
      font-size: 1.999rem;
  }
  h4, .retro-h4 {
      font-size: 1.414rem;
  }
  h5, .retro-h5 {
      font-size: 1.121rem;
  }
  h6, .retro-h6 {
      font-size: .88rem;
  }
  small, .retro-small {
      font-size: .707em;
  }

  img, canvas, iframe, video, svg, select, textarea { max-width: 100%; }

  html, body {
      /* background-image: url(https://raw.githubusercontent.com/apaz-cli/apaz-cli.github.io/master/pattern.png); */
      background-color: #222;
      min-height: 100%;
      font-size: 20px;
  }
  body {
      color: #fafafa;
      /* font-family:  "lemon", "Courier New"; */
      line-height: 1.65;
      max-width: 48rem;
      margin: 6rem auto 1rem;
      /* padding: .25rem; */
  }
  pre, code {
      background-color: #333;
      font-family: "lemon", "Menlo", "Monaco", "Courier New";
      font-size: 12;
  }

  code span.dt { color: #e4a51e; } /* DataType */

  pre {
      padding: .5rem;
      line-height: 1.25;
      overflow-x: scroll;
  }
  blockquote {
      border-left: 3px solid #01ff70;
      padding-left: 1rem;
  }
  </style>
</head>
<body>
<p><img src="images/Tunnel.jpg" /></p>
<hr>
<h1 id="how-to-write-a-compiler-without-going-insane">How to Write a
Compiler Without Going Insane</h1>
<h4
id="there-are-plenty-of-tutorials-out-there-on-how-to-write-compilers.-theyre-all-mostly-the-same.">There
are plenty of tutorials out there on how to write compilers. They're all
mostly the same.</h4>
<p>Usually, the pipeline looks something like:</p>
<ul>
<li>Raw text -&gt; Tokens</li>
<li>Tokens -&gt; Abstract Syntax Tree (AST)</li>
<li>AST -&gt; Symbol Table (Symtab), Intermediate Representation (IR),
Control Flow Graph (CFG)</li>
<li>Symtab, Unoptimized IR, CFG -&gt; Symtab, Optimized IR, Optimized
CFG</li>
<li>Symtab, Optimized IR, Optimized CFG -&gt; Target platform</li>
</ul>
<p><br></p>
<p>    You can add, subtract, swap out, or combine steps, rename and
reinvent things, obsess over details, and argue over semantics all you
like, but everyone agrees that's roughly how you make a compiler.
There's a set of data structures, algorithms, and techniques that
everyone uses, mixes, and matches. Learning to build compilers is mostly
about getting comfortable with them.</p>
<p>    This article is not about that. It's an unhinged rant about how
to get all of that nonsense accomplished without ending up in a mental
ward.</p>
<p><br></p>
<h2 id="why-are-compiler-authors-their-own-worst-enemies">Why are
compiler authors their own worst enemies?</h2>
<div style="text-align: center;">
<p><img src="images/Straightjacket_Man.jpg" /></p>
</div>
<p>    If you're the sort to write a compiler, you are not the sort to
cope with imperfection. That's the reason you're here in the first
place. It's a good thing. But it's also a very bad thing. Trying to get
everything perfect in one go will crush you. Don't ask me how I
know.</p>
<p>    The skills that you need are not technical skills. They're
project management skills.</p>
<p>    This is a Herculean undertaking. The amount of work is
ridiculous. Each stage of the compilation pipeline is large enough to be
a project of its own, and they all need to work together. Most
programming projects are small enough that you can just write the code,
it does the thing, and you can move on. Compilers are different.
Mistakes compound, and can invalidate months of work if you're not
careful.</p>
<p><br></p>
<h2 id="resist-scope-creep">Resist scope creep</h2>
<div style="text-align: center;">
<p><img src="images/20_Minutes_Adventure.gif" /></p>
</div>
<p>    This is perhaps the most important advice. Scope creep. Don't.
You will feel to the urge to create endless complementary side projects.
You could work on...</p>
<ul>
<li>Editor support</li>
<li>Package Manager</li>
<li>Standard Library</li>
<li>Syntax Highlighting</li>
<li>Debugger</li>
<li>Language Server</li>
</ul>
<p>    These can all be accomplished later, and are best accomplished
with support from either multiple teams or large communities. Not by
independent devs trying to do everything. Don't try to undertake all of
these. You and your project will both die. Limit the scope of what
you're doing as much as you can.</p>
<p><br></p>
<h2 id="dont-argue-over-the-color-of-the-bike-shed.">Don't argue over
the color of the bike shed.</h2>
<div style="text-align: center;">
<p><img src="images/Bikeshedding.png" /></p>
</div>
<p>    There are a lot of decisions that are important. Mistakes can
compound. Many mistakes however cannot compound. You don't have to get
those decisions right on the first try.</p>
<p>    Often, compiler authors write languages for reasons of syntax.
There's nothing wrong with that. However, the syntax of your language is
not important to the way your compiler works. Any part of the syntax
that you get wrong can be fixed later with minimal effort, and you'll
end up with the same abstract syntax tree at the end of the parser
anyway. Too many would-be language designers get stuck at this step. Do
not spend too much time here. It is bikeshedding, and will consume you
if you let it.</p>
<p>    To clarify, syntax is not something to spend time on, so long as
there are no grammatical ambiguities. That is an issue which is an issue
that actually could compound into further issues down the road. In
general, whenever you need to make a decision, the time that you spend
on it should be correlated to its importance.</p>
<p><br></p>
<h2 id="plan-out-modular-components">Plan out modular components</h2>
<div style="text-align: center;">
<p><img src="images/Puzzle.jpg" /></p>
</div>
<p>    Remember that part where I said "You can add, subtract, swap out,
or combine steps, rename and reinvent things, obsess over details, and
argue over semantics all you like?" This is the part where you do that.
The first step to writing any compiler is to plan out how all the
different parts connect to each other.</p>
<p>    The calling of computer scientists is to take an insurmountable
problem (like writing a compiler), split it into a few difficult
problems (steps in the compilation pipeline), split those problems into
less difficult problems (algorithms used to implement those steps), and
solve those problems (implement the algorithms).</p>
<p>    Unless you're working with other developers and want to divide
and conquer, you don't need to bust out the UML diagrams. But you do
need a mental image of how the whole project will together. The same
goes for any other software project.</p>
<p>    There's a lot of potential here to mess up in ways that could
come back to haunt you. Forward planning should prevent most of them.
But, there are also a lot of arbitrary decisions that don't matter.
Should you use a GLR parser, a LALR parser, a packrat parser, or write
your own with Pratt parsing or recursive decent? The truth is that it
doesn't matter. What matters is that you get it done so that you can
move on to the next step.</p>
<p>    I could have taken my own advice. Instead I succumbed to
bikeshedding. I hated all the options so much that I spent six months
writing my own parser generator called <a
href="https://github.com/apaz-cli/pgen">pgen</a>. Don't make the same
mistake that I did. If you find <code>pgen</code> helpful though, then
I'm glad I could be of service.</p>
<p><br></p>
<h2 id="manage-your-schedule">Manage your schedule</h2>
<div style="text-align: center;">
<p><img src="images/What_Is_Sleep_Anyway.png" /></p>
</div>
<p>    Writing a compiler is a marathon, not a sprint. Much like
deciding to run a marathon, you should probably first ask if this is a
lifestyle decision that makes sense for you right now. Do you have time
to set aside? Would you rather spend that time with friends or a
significant other? If you want to write a compiler for a project to put
on your resume, there are projects that look just as impressive and are
at least 20x more time efficient.</p>
<p>    My advice is to only work on your compiler when you want to. But
make every session count. Also, don't let other things in your life
become neglected.</p>
<p><br></p>
<h2 id="make-incremental-progress">Make incremental progress</h2>
<div style="text-align: center;">
<p><img src="images/Mountain_Girl.jpg" /></p>
</div>
<p>    Marathons are long. But they are also peppered with landmarks
along the way. Getting to each landmark is its own battle that gets you
closer to the goal. I believe that the same approach applies to compiler
development. What follows is my own opinion and my own system. You
should find a system that works for you.</p>
<p>    It's important to keep track of both be big and small picture. I
maintain two different TODO lists, one for each. Whenever I sit down to
work on the project, I first spend a few minutes calling to mind and
updating my mental model of the big picture, then decide on individual
small tasks from the other list that I want to accomplish in that
session. At the end of the session, before I step away from my laptop, I
update the lists.</p>
<p>    Big picture tasks are easy to keep track of. If you've written a
tokenizer and a parser, and it's time to move on to AST desugaring, then
it's relatively easy to know where you are in the process. What requires
more thought is dealing with change, finalizing parts of the API, and
making sure that everything still makes sense at a macro scale.</p>
<p>    The small tasks are more difficult to keep track of. I find that
I need to make a list, and oftentimes update it as I program, or I will
forget most of it. Tasks on this list could be implementing certain
functions or features, fixing bugs, testing functions or features,
making decisions both large and small scale, and all the other tiny
individual tasks that are part of the goal.</p>
<p>    Prioritizing and building a queue out of the small task list is a
great way to contextualize the large task list, especially since some
tasks on the small list are to make large decisions. Many of my tasks
are literally just thinking about things like type systems,
optimizations, etc. The thinking tasks should generally be about the
things that you really don't want to get wrong. Don't bikeshed. If you
can make a wrong decision without having to redo a lot of work, then
just do so and don't feel bad about it.</p>
<p><br></p>
<h2 id="in-conclusion">In Conclusion</h2>
<ul>
<li>Learn to cope with imperfection.</li>
<li>Constrain the scope of the work. Do not let it creep.</li>
<li>Don't bikeshed. You can always repaint the shed.
<ul>
<li>In particular, do not spend too much time on syntax.</li>
</ul></li>
<li>Spend more time thinking about decisions that could be difficult to
paint over later.
<ul>
<li>Make sure there are no large gaps in your understanding, or in data
flow.</li>
<li>In particular, flesh out the internal APIs and representation of
concepts in your language.</li>
</ul></li>
<li>Manage your schedule.
<ul>
<li>Decide if you really want to do this.</li>
<li>Don't let yourself burn out.</li>
</ul></li>
<li>Make incremental progress
<ul>
<li>Keep an eye on both the big picture and the small picture.</li>
<li>Find a system for accomplishing that which works for you.</li>
</ul></li>
</ul>
<p><br></p>
<p>I may have just reinvented basic project management principles, but I
hope that this unhinged rant has been useful to you.</p>
</body>
</html>
